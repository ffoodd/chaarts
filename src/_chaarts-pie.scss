@use "sass:list";
@use "sass:map";
@use "abstracts/functions";
@use "abstracts/mixins";
@use "abstracts/variables";

/* ==================== */
/* == Pie Charts
/* ==================== */
.pie-container .fieldset {
	display: flex !important;
	margin-bottom: 0;
}

.chaarts.pie {
	--radius: 32em;
	margin: 0 auto;
	padding-top: calc(var(--radius) - #{variables.$gutter * 2});
	position: relative;

	tbody {
		display: table-row;
	}

	tr {
		display: table-cell;
		transition: opacity .3s map.get(variables.$timing-functions, 'move');
	}

	[scope="row"] {
		padding-right: variables.$gutter * 0.5;

		&::before {
			background: var(--color, currentColor) var(--background);
			content: "";
			display: inline-block;
			height: variables.$gutter;
			transform: translate3d(-.2rem, .1rem, 0);
			width: variables.$gutter;
		}
	}

	td {
		--position: calc(var(--start, 0) * .01turn);
	}

	td::after,
	td::before {
		left: 50%;
		position: absolute;
		top: calc(var(--radius) / 2);
		transform-origin: center center;
	}

	/**
	 * Using clip-path + calc() + transform + CSS vars
	 * Using mask-image to make a circle
	 *
	 * 1.
	 * @note Based on Ana Tudor's work
	 * @link https://css-tricks.com/1-html-element-5-css-properties-magic/
	 * @author Ana Tudor
	 *
	 * 2.
	 * @note Using a Roma Komarov's idea about boolean custom properties
	 * @link https://www.kizu.ru/conditions-for-css-variables/
	 *
	 * 3.
	 * @note Mask support:
	 * @link https://caniuse.com/#search=mask
	 */
	td::before {
		--zoom: .75;
		--part: calc(var(--value) * 3.6);
		--main-angle: calc(var(--part) - (90 * (var(--gt-25, 0) + var(--gt-50, 0) + var(--gt-75, 0))));
		--β: calc(var(--main-angle) * 0.01745329251);
		--α: calc((90 - var(--main-angle)) * 0.01745329251);
		@include mixins.sin(β);
		@include mixins.sin(α);
		--pos-B: calc(var(--sin-β) * 50);
		--pos-A: calc(var(--sin-α) * 50);
		--polygon: polygon(
				50% 50%,
				50% 0%,
				100% 0%,
				calc(50% + (var(--pos-B) * 1% * var(--lt-25, 1)) + (var(--gt-25, 0) * 50%)) calc(50% - (var(--pos-A) * 1% * var(--lt-25, 1))),
				calc(50% + (var(--gt-25, 0) * 50%)) calc(50% + (var(--gt-25, 0) * 50%)),
				calc(50% + (var(--pos-A) * 1% * var(--lt-50, 1)) + (var(--gt-50, 0) * 50%)) calc(50% + (var(--pos-B) * 1% * var(--lt-50, 1)) + (var(--gt-50, 0) * 50%)),
				calc(50% - (var(--gt-50, 0) * 50%)) calc(50% + (var(--gt-50, 0) * 50%)),
				calc(50% - (var(--pos-B) * 1% * var(--lt-75, 1)) - (var(--gt-75, 0) * 50%)) calc(50% + (var(--pos-A) * 1% * var(--lt-75, 1))),
				calc(50% - (var(--gt-75, 0) * 50%)) calc(50% - (var(--gt-75, 0) * 50%)),
				calc(50% - (var(--pos-A) * 1% * var(--gt-75, 0))) calc(50% - (var(--pos-B) * 1% * var(--gt-75, 0))),
				50% 50%
		);
		background: var(--color, currentColor) var(--background);
		clip-path: var(--polygon);
		content: '';
		height: var(--radius);
		--mask: radial-gradient(
				circle at center,
				#fff 0 calc(var(--radius) / 2),
				transparent 0
		);
		mask-image: var(--mask);
		transform: translate3d(-50%, -50%, 0) rotate(var(--position)) scale(var(--zoom));
		transition: transform .2s map.get(variables.$timing-functions, 'move');
		width: var(--radius);
	}

	tr:hover td::before {
		--zoom: .8;
	}

	@each $name, $pattern in variables.$patterns {
		$i: list.index(variables.$patterns, ($name $pattern));

		tr:nth-child(#{$i}n + #{$i}) {
			--background: var(--#{$name}); // 1
		}
	}

	/**
	 * 1.
	 * @note Display CSS integers custom properties with a trick using counters
	 * @author Cassie Evans
	 * @link https://codepen.io/cassie-codes/pen/22ea69e0f681d45f2f4c2ca5e6acf4ab
	 *
	 * 2.
	 * @note We need to ensure our counter uses an integer, --value might a a floating number
	 * @author Carter Li
	 * @link https://css-tricks.com/animating-number-counters/#the-new-school-css-solution
	 */
	td::after {
		--arrow: calc(100% - #{variables.$gutter * 0.25});
		--axis: calc(var(--position) - .25turn + var(--value) * .005turn);
		--away: calc(var(--radius) / 2 - #{variables.$gutter});
		--integer: calc(var(--value)); // 2
		background-color: functions.palette(dominant);
		color: functions.palette(dominant, contrast);
		content: var(--term) "\A0: " counter(value) "\A0%"; // 1
		counter-reset: value var(--integer); // 1
		opacity: 0;
		padding: variables.$gutter * 0.5;
		pointer-events: none;
		transform-origin: 50% calc(100% + 10px);
		transform: translate3d(-50%, -50%, 0) rotate(var(--axis)) translate(var(--away)) rotate(calc(var(--axis) * -1)) perspective(1000px) rotate3d(1, 0, 0, 45deg);
		transition: opacity .2s map.get(variables.$timing-functions, 'enter'),
		transform .2s map.get(variables.$timing-functions, 'enter');
	}

	tbody:hover tr {
		opacity: .5;

		&:hover {
			opacity: 1;
		}

		&:hover td::after {
			opacity: 1;
			transform: translate3d(-50%, -50%, 0) rotate(var(--axis)) translate(var(--away)) rotate(calc(var(--axis) * -1)) perspective(1000px) rotate3d(1, 0, 0, 0deg);
			transition: opacity .2s map.get(variables.$timing-functions, 'exit'),
			transform .2s map.get(variables.$timing-functions, 'exit');
		}
	}
}

.chaarts.polar {
	td::before {
		--zoom: 50;
		transform: translate3d(-50%, -50%, 0) rotate(var(--position)) scale(calc((var(--zoom) + (var(--value) / (100 / var(--zoom)))) / 100));
	}

	td::after {
		--away: calc((var(--radius) / 2) - ((var(--radius) / 4) * ((100 - var(--value)) / 100)) + #{variables.$gutter * 2.5});
	}

	tr:hover td::before {
		--zoom: 50;
	}
}

.chaarts.donut {
	--mask: radial-gradient(
			circle at 50% calc(50% - #{variables.$gutter  * 0.25}),
			transparent 0 var(--offset),
			#fff calc(var(--offset) + 1px) 100%
	);
	mask-image: var(--mask);

	td::after {
		--away: calc(var(--radius) / 2 - #{variables.$gutter * 2.5});
	}
}

@media screen and (-ms-high-contrast: active) {
	.chaarts.pie {
		tbody tr *::before {
			/**
			 * @note Custom color palette for WHCM
			 * @note Inspired by Greg Whitworth's post
			 * @link http://www.gwhitworth.com/blog/2017/04/how-to-use-ms-high-contrast
			 */
			background-color: Window;
		}

		tbody tr:nth-of-type(odd) *::before {
			background-color: WindowText;
		}
	}
}
