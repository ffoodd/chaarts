@use "sass:list";
@use "sass:map";
@use "abstracts/variables";

/* ==================== */
/* == Pie Charts
/* ==================== */

.chaarts.pie {
	--radius: 32em;
	margin: 0 auto;
	padding-block-start: calc(var(--radius) - #{variables.$gutter * 2});
	position: relative;

	tbody {
		display: table-row;
	}

	tr {
		display: table-cell;
		transition: opacity .3s var(--move);
	}

	[scope="row"] {
		padding-inline-end: variables.$gutter * 0.5;

		&::before {
			background: var(--color, currentColor) var(--background);
			content: "";
			display: inline-block;
			block-size: variables.$gutter;
			translate: calc(-.2rem * var(--is-rtl, 1)) .1rem 0;
			inline-size: variables.$gutter;
		}
	}

	td {
		--position: calc(var(--start, 0) * .01turn);
	}

	td::after,
	td::before {
		inset-inline-start: 50%;
		position: absolute;
		inset-block-start: calc(var(--radius) / 2);
		transform-origin: center center;
	}

	[dir="rtl"] & td::after {
		inset-inline-start: 40%;
	}

	/**
	 * Using clip-path + calc() + transform + CSS vars
	 * Using mask-image to make a circle
	 *
	 * 1.
	 * @note Based on Ana Tudor's work
	 * @link https://css-tricks.com/1-html-element-5-css-properties-magic/
	 * @author Ana Tudor
	 *
	 * 2.
	 * @note Using a Roma Komarov's idea about boolean custom properties
	 * @link https://www.kizu.ru/conditions-for-css-variables/
	 *
	 * 3.
	 * @note Mask support:
	 * @link https://caniuse.com/#search=mask
	 */
	td::before {
		--zoom: .75;
		--part: calc(var(--value) * 3.6);
		--main-angle: calc(var(--part) - (90 * (var(--gt-25, 0) + var(--gt-50, 0) + var(--gt-75, 0))));
		--β: calc(var(--main-angle) * 0.01745329251);
		--α: calc((90 - var(--main-angle)) * 0.01745329251);
		--sin-β: sin(var(--β));
		--sin-α: sin(var(--α));
		--pos-B: calc(var(--sin-β) * 50);
		--pos-A: calc(var(--sin-α) * 50);
		--polygon: polygon(
				50% 50%,
				50% 0%,
				100% 0%,
				calc(50% + (var(--pos-B) * 1% * var(--lt-25, 1)) + (var(--gt-25, 0) * 50%)) calc(50% - (var(--pos-A) * 1% * var(--lt-25, 1))),
				calc(50% + (var(--gt-25, 0) * 50%)) calc(50% + (var(--gt-25, 0) * 50%)),
				calc(50% + (var(--pos-A) * 1% * var(--lt-50, 1)) + (var(--gt-50, 0) * 50%)) calc(50% + (var(--pos-B) * 1% * var(--lt-50, 1)) + (var(--gt-50, 0) * 50%)),
				calc(50% - (var(--gt-50, 0) * 50%)) calc(50% + (var(--gt-50, 0) * 50%)),
				calc(50% - (var(--pos-B) * 1% * var(--lt-75, 1)) - (var(--gt-75, 0) * 50%)) calc(50% + (var(--pos-A) * 1% * var(--lt-75, 1))),
				calc(50% - (var(--gt-75, 0) * 50%)) calc(50% - (var(--gt-75, 0) * 50%)),
				calc(50% - (var(--pos-A) * 1% * var(--gt-75, 0))) calc(50% - (var(--pos-B) * 1% * var(--gt-75, 0))),
				50% 50%
		);
		background: var(--color, currentColor) var(--background);
		border-radius: 50%;
		clip-path: var(--polygon);
		content: '';
		block-size: var(--radius);
		--mask: radial-gradient(
				circle at center,
				#ffff 0 calc((var(--radius) / 2) - 1px),
				#0000 0
		);
		mask-image: var(--mask);
		transform: translate3d(calc(-50%* var(--is-rtl, 1)), -50%, 0) rotate(var(--position)) scale(var(--zoom));
		transition: transform .2s var(--move);
		inline-size: var(--radius);
	}

	tr:hover td::before {
		--zoom: .8;
	}

	@each $pattern in variables.$patterns {
		$i: list.index(variables.$patterns, $pattern);

		tr:nth-child(#{$i}n + #{$i}) {
			--background: var(--#{$pattern});
		}
	}

	/**
	 * 1.
	 * @note Display CSS integers custom properties with a trick using counters
	 * @author Cassie Evans
	 * @link https://codepen.io/cassie-codes/pen/22ea69e0f681d45f2f4c2ca5e6acf4ab
	 *
	 * 2.
	 * @note We need to ensure our counter uses an integer, --value might a a floating number
	 * @author Carter Li
	 * @link https://css-tricks.com/animating-number-counters/#the-new-school-css-solution
	 */
	td::after {
		--arrow: calc(100% - #{variables.$gutter * 0.25});
		--axis: calc(var(--position) - .25turn + var(--value) * .005turn);
		--away: calc(var(--radius) / 2 - #{variables.$gutter});
		--integer: calc(var(--value)); // 2
		background-color: var(--foreground-lighter);
		color: var(--background-lighter);
		content: var(--term) "\A0: " counter(value) "\A0%"; // 1
		counter-reset: value var(--integer); // 1
		opacity: 0;
		padding: variables.$gutter * 0.5;
		pointer-events: none;
		transform-origin: 50% calc(100% + 10px);
		transform: translate3d(-50%, -50%, 0) rotate(var(--axis)) translate(var(--away)) rotate(calc(var(--axis) * -1)) perspective(1000px) rotate3d(1, 0, 0, 45deg);
		transition: opacity .2s var(--enter),
		transform .2s var(--enter);
	}

	tbody:hover tr {
		opacity: .5;

		&:hover {
			opacity: 1;
		}

		&:hover td::after {
			opacity: 1;
			transform: translate3d(-50%, -50%, 0) rotate(var(--axis)) translate(var(--away)) rotate(calc(var(--axis) * -1)) perspective(1000px) rotate3d(1, 0, 0, 0deg);
			transition: opacity .2s var(--exit),
			transform .2s var(--exit);
		}
	}
}

.chaarts.polar {
	td::before {
		--zoom: 50;
		transform: translate3d(calc(-50%* var(--is-rtl, 1)), -50%, 0) rotate(var(--position)) scale(calc((var(--zoom) + (var(--value) / (100 / var(--zoom)))) / 100));
	}

	td::after {
		--away: calc((var(--radius) / 2) - ((var(--radius) / 4) * ((100 - var(--value)) / 100)) + #{variables.$gutter * 2.5});
	}

	tr:hover td::before {
		--zoom: 50;
	}
}

.chaarts.donut {
	--mask: radial-gradient(
			circle at 50% calc(50% - #{variables.$gutter  * 0.25}),
			#0000 0 var(--offset),
			#ffff calc(var(--offset) + 1px) 100%
	);
	mask-image: var(--mask);

	td::after {
		--away: calc(var(--radius) / 2 - #{variables.$gutter * 2.5});
	}
}
